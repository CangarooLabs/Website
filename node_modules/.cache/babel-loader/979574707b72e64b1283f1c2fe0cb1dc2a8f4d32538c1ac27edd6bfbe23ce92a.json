{"ast":null,"code":"import { Vector, getDistances, getStyleFromRgb, rangeColorToRgb } from \"tsparticles-engine\";\nexport function drawPolygonMask(context, rawData, stroke) {\n  const color = rangeColorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n  for (const item of rawData) {\n    context.lineTo(item.x, item.y);\n  }\n  context.closePath();\n  context.strokeStyle = getStyleFromRgb(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n  context.setTransform(1, 0, 0, 1, position.x, position.y);\n  const color = rangeColorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n  context.setTransform(1, 0, 0, 1, 0, 0);\n}\nexport function parsePaths(paths, scale, offset) {\n  const res = [];\n  for (const path of paths) {\n    const segments = path.element.pathSegList,\n      len = segments?.numberOfItems ?? 0,\n      p = {\n        x: 0,\n        y: 0\n      };\n    for (let i = 0; i < len; i++) {\n      const segment = segments?.getItem(i),\n        svgPathSeg = window.SVGPathSeg;\n      switch (segment?.pathSegType) {\n        case svgPathSeg.PATHSEG_MOVETO_ABS:\n        case svgPathSeg.PATHSEG_LINETO_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n        case svgPathSeg.PATHSEG_ARC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n          {\n            const absSeg = segment;\n            p.x = absSeg.x;\n            p.y = absSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n          p.x = segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n          p.y = segment.y;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_REL:\n        case svgPathSeg.PATHSEG_MOVETO_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n        case svgPathSeg.PATHSEG_ARC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n          {\n            const relSeg = segment;\n            p.x += relSeg.x;\n            p.y += relSeg.y;\n            break;\n          }\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n          p.x += segment.x;\n          break;\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n          p.y += segment.y;\n          break;\n        case svgPathSeg.PATHSEG_UNKNOWN:\n        case svgPathSeg.PATHSEG_CLOSEPATH:\n          continue;\n      }\n      res.push({\n        x: p.x * scale + offset.x,\n        y: p.y * scale + offset.y\n      });\n    }\n  }\n  return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n  const {\n      dx: dx1,\n      dy: dy1\n    } = getDistances(pos, s1),\n    {\n      dx: dx2,\n      dy: dy2\n    } = getDistances(s2, s1),\n    t = (dx1 * dx2 + dy1 * dy2) / (dx2 ** 2 + dy2 ** 2),\n    res = {\n      x: s1.x + dx2 * t,\n      y: s1.y + dy2 * t,\n      isOnSegment: t >= 0 && t <= 1\n    };\n  if (t < 0) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > 1) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n  return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n  const {\n      dx,\n      dy\n    } = getDistances(start, stop),\n    wallAngle = Math.atan2(dy, dx),\n    wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n    d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}","map":{"version":3,"names":["Vector","getDistances","getStyleFromRgb","rangeColorToRgb","drawPolygonMask","context","rawData","stroke","color","beginPath","moveTo","x","y","item","lineTo","closePath","strokeStyle","lineWidth","width","drawPolygonMaskPath","path","position","setTransform","opacity","parsePaths","paths","scale","offset","res","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","calcClosestPtOnSegment","s1","s2","pos","dx","dx1","dy","dy1","dx2","dy2","t","isOnSegment","segmentBounce","start","stop","velocity","wallAngle","Math","atan2","wallNormal","create","sin","cos","d","multTo","subFrom"],"sources":["C:/Users/User/Desktop/Cangaroo Labs/Website/node_modules/tsparticles-plugin-polygon-mask/esm/utils.js"],"sourcesContent":["import { Vector, getDistances, getStyleFromRgb, rangeColorToRgb } from \"tsparticles-engine\";\r\nexport function drawPolygonMask(context, rawData, stroke) {\r\n    const color = rangeColorToRgb(stroke.color);\r\n    if (!color) {\r\n        return;\r\n    }\r\n    context.beginPath();\r\n    context.moveTo(rawData[0].x, rawData[0].y);\r\n    for (const item of rawData) {\r\n        context.lineTo(item.x, item.y);\r\n    }\r\n    context.closePath();\r\n    context.strokeStyle = getStyleFromRgb(color);\r\n    context.lineWidth = stroke.width;\r\n    context.stroke();\r\n}\r\nexport function drawPolygonMaskPath(context, path, stroke, position) {\r\n    context.setTransform(1, 0, 0, 1, position.x, position.y);\r\n    const color = rangeColorToRgb(stroke.color);\r\n    if (!color) {\r\n        return;\r\n    }\r\n    context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\r\n    context.lineWidth = stroke.width;\r\n    context.stroke(path);\r\n    context.setTransform(1, 0, 0, 1, 0, 0);\r\n}\r\nexport function parsePaths(paths, scale, offset) {\r\n    const res = [];\r\n    for (const path of paths) {\r\n        const segments = path.element.pathSegList, len = segments?.numberOfItems ?? 0, p = {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        for (let i = 0; i < len; i++) {\r\n            const segment = segments?.getItem(i), svgPathSeg = window.SVGPathSeg;\r\n            switch (segment?.pathSegType) {\r\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\r\n                case svgPathSeg.PATHSEG_LINETO_ABS:\r\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\r\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\r\n                case svgPathSeg.PATHSEG_ARC_ABS:\r\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\r\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\r\n                    const absSeg = segment;\r\n                    p.x = absSeg.x;\r\n                    p.y = absSeg.y;\r\n                    break;\r\n                }\r\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\r\n                    p.x = segment.x;\r\n                    break;\r\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\r\n                    p.y = segment.y;\r\n                    break;\r\n                case svgPathSeg.PATHSEG_LINETO_REL:\r\n                case svgPathSeg.PATHSEG_MOVETO_REL:\r\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\r\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\r\n                case svgPathSeg.PATHSEG_ARC_REL:\r\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\r\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\r\n                    const relSeg = segment;\r\n                    p.x += relSeg.x;\r\n                    p.y += relSeg.y;\r\n                    break;\r\n                }\r\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\r\n                    p.x += segment.x;\r\n                    break;\r\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\r\n                    p.y += segment.y;\r\n                    break;\r\n                case svgPathSeg.PATHSEG_UNKNOWN:\r\n                case svgPathSeg.PATHSEG_CLOSEPATH:\r\n                    continue;\r\n            }\r\n            res.push({\r\n                x: p.x * scale + offset.x,\r\n                y: p.y * scale + offset.y,\r\n            });\r\n        }\r\n    }\r\n    return res;\r\n}\r\nexport function calcClosestPtOnSegment(s1, s2, pos) {\r\n    const { dx: dx1, dy: dy1 } = getDistances(pos, s1), { dx: dx2, dy: dy2 } = getDistances(s2, s1), t = (dx1 * dx2 + dy1 * dy2) / (dx2 ** 2 + dy2 ** 2), res = {\r\n        x: s1.x + dx2 * t,\r\n        y: s1.y + dy2 * t,\r\n        isOnSegment: t >= 0 && t <= 1,\r\n    };\r\n    if (t < 0) {\r\n        res.x = s1.x;\r\n        res.y = s1.y;\r\n    }\r\n    else if (t > 1) {\r\n        res.x = s2.x;\r\n        res.y = s2.y;\r\n    }\r\n    return res;\r\n}\r\nexport function segmentBounce(start, stop, velocity) {\r\n    const { dx, dy } = getDistances(start, stop), wallAngle = Math.atan2(dy, dx), wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)), d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\r\n    wallNormal.multTo(d);\r\n    velocity.subFrom(wallNormal);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}